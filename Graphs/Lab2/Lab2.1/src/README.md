# Построение остаточного дерева (MST)

### Алгоритм Борувки:

1. Изначально каждая вершина представляет собой отдельную компоненту связности.
2. На каждой итерации для каждой компоненты связности находим ребро минимального веса, соединяющее эту компоненту с другой.
3. Объединяем компоненты связности, используя найденные рёбра.
4. Повторяем шаги 2-3, пока не останется одна компонента связности. (While)

Более ясно:

1. Инициализируем DSU, каждая вершина в своей компоненте.
2. Пока количество компонент больше 1:
    a) Создаем массив (или вектор) для хранения минимального ребра для каждой компоненты (изначально пустое).
    b) Распараллеливаем процесс обхода рёбер для нахождения минимального ребра, исходящего из каждой компоненты.

### Особенности параллельной реализации:

- Каждый поток обрабатывает свою группу компонент и создает локальный массив с кандидатами на следующую рассматриваемую вершину
- После один поток или многопоток с помощью мютекса удаляет дупликаты и выбирает сам слудющую точку из всех локальных массивов создает один глобавльный
- Весь массив точек делим на chunks по одному chunk на поток и в своем чанке он создает и заполняет массив кандидатов то есть ```chunks[i]``` - это вершина-кандидат для i-ой компоненты


#### Почему двойная проверка (вторая if) нужна, даже с мутексом?
Если убрать вторую if (двойную проверку), код станет таким:

```cpp
if (min_w < curr_w) {
    std::lock_guard<std::mutex> lock(mtx);
    min_edge_per_comp[root_u] = {min_w, u, best_v};  // Прямая запись
}
```
**Проблема:** Между первой проверкой ```(if (min_w < curr_w))``` и блокировкой ```(lock(mtx))``` другой поток может уже обновить ```min_edge_per_comp[root_u]``` (сделать его ещё меньше). 
В итоге мы перезапишем его "старым" значением min_w, хотя оно уже не минимум! Это приведёт к гокне данных и неверному результату (потерянному минимуму).
**Пример:** Поток A читает curr_w = 10, видит min_w = 5 < 10, входит в блок. Но пока ждёт lock, поток B обновляет на min_w = 3 (ещё лучше). Потом A блокирует и записывает 5, стирая 3 — ошибка!

Поэтому сделали так:
```cpp
auto [curr_w, curr_u, curr_v] = min_edge_per_comp[root_u];  // Читаем текущее значение ВНЕ блокировки
if (min_w < curr_w) {
    std::lock_guard<std::mutex> lock(mtx);  // Блокируем
    // ДВОЙНАЯ ПРОВЕРКА ВНУТРИ блокировки:
    if (min_w < std::get<0>(min_edge_per_comp[root_u])) {
        min_edge_per_comp[root_u] = {min_w, u, best_v};  // Обновляем
    }
}
```

---

### Что такое rank и как оно работает коде?

**Rank** — это "примерная высота" дерева в DSU. Каждый корень компоненты имеет свой rank (начинает с 0). Это не точная высота, а просто счётчик для балансировки.
В DSU компоненты — это деревья (каждая вершина имеет родителя parent), и когда мы объединяем две компоненты (union_components), мы "прикрепляем" один корень к другому.

**!!** Всегда прикрепляем меньший rank к большему. Если равны — увеличиваем rank на 1. Это делает деревья сбалансированными (почти плоскими), чтобы поиск корня (find_component) был быстрым.

- find_component вызывается много раз: в параллельном поиске (для u и v), в сборе кандидатов, в объединении.
- Если DSU не оптимизировано, параллельные потоки будут тормозить на find (особенно с path compression, но без rank дерево может вырасти).
**Минусы убрать:**
- В худшем случае (граф — цепочка) find станет O(n), и параллелизация потеряет смысл (потоки будут ждать).


### Использование emplace_back
**Ключевые различия:**
- ```push_back``` требует создания объекта заранее, затем его перенос в контейнер.
- ```emplace_back``` создаёт объект на месте, передавая аргументы конструктора.
- Для простых типов (int, string) разница минимальна, но для сложных — emplace_back лучше.

**Почему не push_back для потоков?**

```std::thread``` — это объект потока, и он не копируемый. Его нельзя копировать из-за внутренней природы (поток нельзя дублировать).
Проблема с push_back:
push_back(thread_obj) не сработает, потому что std::thread не имеет копирующего конструктора.
Можно использовать push_back(std::move(thread_obj)), но это требует создания потока заранее, затем перемещения — неудобно и рискованно (если поток уже запущен).


### Что такое эвристика сжатия путей?

**Эвристика сжатия путей** — это оптимизация в структуре данных Union-Find, которая ускоряет операцию поиска корня множества. Она используется в алгоритмах, где нужно быстро объединять и проверять принадлежность элементов к группам.

#### **Как работает сжатие путей?**
- В Union-Find каждый элемент имеет "родителя" (ссылку на другого элемент или на себя, если он корень множества).
- Операция Find ищет корень: рекурсивно поднимается по родителям до корня.
- **Сжатие путей:** Во время поиска, для каждого узла на пути к корню, родитель устанавливается напрямую на корень. Это делает будущие поиски быстрее, так как путь сокращается.
- **Пример**:
```cpp
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);  // Сжатие: устанавливаем родителя на корень
    }
    return parent[x];
}
```
- **Без сжатия:** Дерево может стать длинным (O(n) операций).
- **С сжатием:** Время на операцию становится почти константным (почти O(1) в среднем, с использованием union by rank).


#### **Чем полезно нам?**

**Сравнение с простым массивом принадлежности компонентам**
- Простой массив (статичный случай): Если бы компоненты никогда не менялись (нет объединений), массив был бы идеален: component_id[i] хранит ID, проверка принадлежности — O(1). 
Но в Борувке компоненты сливаются динамически!

  - **Проблема:** После каждого объединения (добавления ребра) нужно обновить ID для всех вершин в объединённой компоненте. Это требует перебора всего графа — O(n) на объединение. Для большого n (например, 10^5 вершин) и множества итераций (до n-1 рёбер) общая сложность взлетит до O(n^2), что неприемлемо.
  - В параллельном коде: Потоки будут тратить время на перестройку массива, плюс нужен мьютекс для синхронизации — тормоз для параллелизма.