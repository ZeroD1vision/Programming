/**
 * @file lib.h
 * @brief Заголовочный файл для параллельной реализации алгоритма Борувки
 * 
 * Содержит объявления классов и функций для поиска минимального остовного дерева
 * с использованием многопоточности.
 */

#ifndef LIB_H
#define LIB_H

#include <vector>
#include <string>
#include <utility>
#include <chrono>
#include <limits>

using namespace std;
using namespace chrono;

const int INF = numeric_limits<int>::max();

/**
 * @class ParallelBoruvka
 * @brief Класс для параллельного поиска минимального остовного дерева алгоритмом Борувки
 * 
 * Реализует параллельную версию алгоритма Борувки с использованием системы
 * непересекающихся множеств (DSU) и многопоточности для ускорения вычислений.
 */
class ParallelBoruvka {
private:
    vector<vector<pair<int, int>>> adj; ///< Список смежности графа
    vector<int> parent;      ///< Массив родителей для DSU
    vector<int> rank;        ///< Массив рангов для оптимизации DSU
    int n_;                  ///< Количество вершин в графе
    int n_threads_;          ///< Количество потоков для параллелизации

    /**
     * @brief Находит корень компоненты связности для вершины
     * @param x Вершина, для которой ищется корень компоненты
     * @return Корень компоненты связности
     * 
     * Использует эвристику сжатия путей для оптимизации последующих вызовов.
     */
    int find_component(int x);

    /**
     * @brief Объединяет две компоненты связности
     * @param x Первая вершина
     * @param y Вторая вершина
     * 
     * Обьединение по рангу для поддержания сбалансированности деревьев.
     */
    void union_components(int x, int y);

public:
    /**
     * @brief Конструктор класса ParallelBoruvka
     * @param graph Граф в виде списка смежности
     * @param n_threads Количество потоков для параллельной обработки
     */
    ParallelBoruvka(const vector<vector<pair<int, int>>>& graph, int n_threads);

    /**
     * @brief Находит минимальное остовное дерево графа
     * @param duration Ссылка на переменную для записи времени выполнения (в мс)
     * @return Вектор рёбер, входящих в минимальное остовное дерево
     * 
     * Реализует параллельный алгоритм Борувки:
     * 1. Каждая вершина образует отдельную компоненту
     * 2. Параллельно ищутся минимальные рёбра между компонентами
     * 3. Компоненты объединяются через найденные рёбра
     * 4. Процесс повторяется до одной компоненты
     */
    vector<pair<int, int>> findMST(double& duration);

    /**
     * @brief Вычисляет суммарный вес минимального остовного дерева
     * @param mst Вектор рёбер минимального остовного дерева
     * @return Суммарный вес всех рёбер в MST
     */
    int calculateTotalWeight(const vector<pair<int, int>>& mst);
};

/**
 * @brief Читает граф из файла в формате списков смежности
 * @param filename Имя входного файла
 * @return Граф в виде списка смежности
 * 
 * Формат файла:
 * - Первая строка: количество вершин
 * - Последующие строки: списки смежности в формате "сосед:вес сосед:вес ..."
 */
vector<vector<pair<int, int>>> readGraph(const string& filename);

/**
 * @brief Генерирует имя тестового файла по номеру теста
 * @param test_num Номер теста (1-10)
 * @return Полный путь к тестовому файлу
 */
string getTestFileName(int test_num);

#endif