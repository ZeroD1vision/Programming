# Алгоритмы Двудольных Графов

## Шаги 

1. **Паросочетание пусто:**

    Это инициализация. Мы начинаем с пустого множества ребер в паросочетании (M = пустой список или множество). Ни одно ребро не "занято". Это значит, что все вершины "свободны" (не покрыты паросочетанием).
    **Цель:** Постепенно добавлять ребра, чтобы покрыть как можно больше вершин без повторений

2. **Ищем увеличивающую цепь, по очереди, начиная из первой в первой доли:**

    - Берем по одной свободной вершине из первой доли (например, вершину, которая еще не соединена ни с кем в паросочетании).
    - Для каждой такой вершины запускаем поиск увеличивающей цепи с помощью DFS (глубинный обход по ребрам). В DFS мы идем по графу: от вершины первой доли по свободному ребру к второй доле, затем оттуда по занятому ребру (из паросочетания) обратно к первой доле и т.д., чередуя ребра.
        - **Если** цепь найдена (заканчивается на свободной вершине второй доли): 
          - цепь пометилась как "увеличивающая" — она позволяет добавить новые ребра и увеличить    паросочетание на 1.
        - **Иначе** (если цепь не найдена для этой вершины):
          - переходим к следующей свободной вершине первой доли.
    Этот шаг повторяется для всех свободных вершин первой доли в этой итерации (поиск "по очереди").

3. **Если она есть, то все ребра цепи, не принадлежащие паросочетанию, добавляем в него, а все принадлежащие паросочетанию, удалим из него:**

    ```
    "Симметризация" (augmenting) цепи: мы "переключаем" ребра вдоль пути.
    ```
    - Ребро в цепи, которое НЕ было в паросочетании M — добавляем его в M.
    - Ребро в цепи, которое БЫЛО в паросочетании M — удаляем его из M.
    	* *Это увеличивает размер паросочетания на 1, потому что теперь одна дополнительная вершина в	первой доле и одна во второй доле "покрыты".*
    	* *После этого все вершины в цепи "симметризующихся" ребер меняют статус (некоторые становятся	занятыми, другие — свободными).*

    - Повторяем весь процесс (возвращаемся к шагу 2), пока не найдём увеличивающую цепь. Когда цепей больше нет, паросочетание максимальное.

---
## Теория

### Двудольность

**Двудольный граф** - граф, вершины которого можно разбить на два непересекающихся множества U и V таких, что:

- U ∪ V = V (все вершины)
- U ∩ V = ∅ (множества не пересекаются)
- Каждое ребро соединяет вершину из U с вершиной из V

(не содержит циклов нечётной длины)

### Алгоритм проверки двудольности

1. Создаём массив color размера n (число вершин), заполняем -1 (не раскрашено).
2. Проходим по всем вершинам. Если color[i] == -1 (вершина не посещена), начинаем новую компоненту:
   - Назначаем color[i] = 0 (красный).
   - Кладём i в *стек*.
3. Основной цикл DFS:
    **Пока** стек не пуст:
    - Извлекаем вершину u с верха стека (LIFO).
    - Для каждого соседа v (по матрице: if (matrix[u][v])):
        - **Если** не раскрашен (color[v] == -1):
            * Назначаем v противоположный цвет.
            * Кладём v в стек (для будущего обхода).
        - **Иначе** (уже раскрашен):
            Если color[v] == color[u] — конфликт! Возвращаем *false* (граф НЕ двудольный).
4. Завершение:
    - Если обработали все компоненты без конфликтов, возвращаем *true* (граф двудольный). Если конфликт — *false*.


### Что такое увеличивающая цепь?

Это путь в графе, который 
   * начинается с свободной вершины в первой доле (не связанной ни с каким ребром в паросочетании).
   * Заканчивается свободной вершиной во второй доле.
   * Вдоль пути ребра чередуются: свободное ребро (не в паросочетании) — занятое ребро (в паросочетании) — свободное — занятое и т.д.

**Увеличивающая цепь** - начинается с свободной вершины в U, чередует рёбра (не-M → M → не-M → ...), и заканчивается насвободной вершине в V.

### Паросочетания

**Паросочетание (matching)** — это подмножество рёбер графа, где никакие две рёбра не имеют общую вершину. В двудольном графе (с левыми и правыми вершинами) паросочетания могут быть разного размера: от пустого (без рёбер) до максимального (как в алгоритме Куна)(по теореме о свадьбе).

### Метод поиска ВСЕХ паросочетаний
Используем простой рекурсивный подход (как DFS для перечисления):

1. Начинаем с пустого паросочетания.
2. Для каждой левой вершины (если свободна), пробуем добавить ребро к возможным правым соседям (если свободны).
3. Рекурсивно делаем, и когда все вершины обработаны, сохраняем результат.
4. После выбора ребра, можно "отменить" его выбор (backtrack) для нахождения альтернатив.

Это даст все возможные matching-и, включая пустой. Чтобы найти мин/макс, просто смотрим на размеры в результате.

---

### Поиск Куна (Проще)

**Когда** такая цепь найдена, мы "инвертируем" ребра:
- занятые делаем свободными, 
- свободные — занятыми. 

*Это увеличивает паросочетание на 1 ребро.*

**Пока** не будет некуда идти в первой половине (все свободные вершины в U "застряли" — от них нельзя дойти до свободной V)


**У НАС**
Мы инвертируем явно ребра рекурсивно в DFS.
- В DFS мы ищем свободную вершину в V для вершины из U, и если находим, то образуем пару.
- **Если** вершина в V уже занята, то мы пытаемся рекурсивно найти новую пару для той вершины из U, которая сейчас связана с этой V. (как с котиками)
    - **Если** это удается, то мы "переподвешиваем" текущую вершину V к новой вершине из U (текущей u) и увеличиваем паросочетание.

В коде это происходит в условии:
```cpp
if (matchV[v_index] == -1 || dfsKuhn(matchV[v_index], ...))
```
Здесь:

- **Если** ```matchV[v_index] == -1```, то вершина V свободна и мы просто связываем u и v.

- **Иначе**, мы пытаемся найти новую пару для вершины matchV[v_index] (которая сейчас связана с v_index).
    - **Если** это удается, то освобождаем v_index и связываем ее с u.

### Теорема (König's theorem):
**Теорема (König's theorem):** Максимальный matching имеет столько рёбер, сколько augmenting paths найдено. Т.е., 

```
число рёбер в maximum matching = число найденных augmenting paths
```

**Почему?** Каждый augmenting path увеличивает размер matching на 1, и мы делаем это до предела.

---

## Код
```cpp
bool dfsKuhn(int u, vector<bool>& visited, vector<int>& matchU, vector<int>& matchV) {
        for (int v = 0; v < n; v++) {
            if (adjMatrix[u][v] && !visited[v]) {
                visited[v] = true;
                
                if (matchV[v] == -1 || dfsKuhn(matchV[v], visited, matchU, matchV)) {
                    matchU[u] = v;
                    matchV[v] = u;
                    return true;
                }
            }
        }
        return false;
    }
```

---

## Вывод в консоль

a) является ли граф двудольным
b) количество ребер в найденном паросочетании (число паросочетаний в смысле количество пар)
c) пофиг
d) ребра паросочетания

Если граф **НЕ** двудольный, то для пунктов b, c, d вывести **0** и **пустой список**.

---

## Замечание

в задании сказано "число паросочетаний", но в примере вывода это не отражено.
В примере вывода:
"Size of maximum matching: 25."
и перечислены ребра.

Поэтому интерпретируем так:
b) число паросочетаний = размер максимального паросочетания (количество ребер в нем)
c) размер максимального паросочетания = то же самое

Но в примере вывода нет отдельного пункта "число паросочетаний", а есть только размер.

Возможно, в задании опечатка и имеется в виду:
b) количество ребер в максимальном паросочетании (число паросочетаний в смысле количество пар)