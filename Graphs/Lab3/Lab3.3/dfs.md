# Обьяснение DFS

###  В нашем коде

1. 
```cpp
bool Graph::dfsKuhn(int u, vector<bool>& visited, vector<int>& matchU, vector<int>& matchV,
const vector<int>& U, const vector<int>& V, const vector<int>& indexInV)
```

- **u:** Локальный индекс вершины в U (например, 0 для первой вершины в U).
- **visited:** Вектор bool, чтобы не посещать ту же вершину V дважды в одном пути (предотвращает loops).
- **matchU и matchV:** Массивы паросочетания (matching). matchU[u] = индекс v в V, если u связан с этим v. Инициализированы -1.
- **U, V:** Векторы с оригинальными номерами вершин. U[u] = оригинальный ID вершины U. (V аналогично, но не используется тут.)
- **indexInV:** Вектор, где indexInV[v] = позиция оригинальной вершины v в множестве V (от 0 до numV-1, для matchV). Зачем? matchV индексирован позицией в V (0..numV-1), а v — оригинальный номер (0..N-1). (Мы в нем ищем *является ли v свободной* ```(matchV[v_index] == -1)``` *или занятой*)


2. 
```cpp
int originalU = U[u];
```

- **u** — входной индекс (локальный для U).
- **originalU = U[u];** — берём оригинальный ID этой вершины. Зачем? Чтобы индексировать matrix: строки matrix соответствуют оригинальным номерам вершин U. Без этого ```matrix[originalU][v]``` сломается, если u не равно оригинальному ID.


3. 
```cpp
for (int v = 0; v < size_; v++)
```

- Перебираем все потенциальные v (от 0 до N-1, где N=size_ — число вершин в графе).
- ```if (matrix[originalU][v] && colors[v] == 1)```: Проверяем: 
    - а) ребро есть (matrix[originalU][v] == 1), 
    - б) v принадлежит V (colors[v] == 1).


4. 
```cpp
int v_index = indexInV[v];
```

- Переводим оригинальный v в его локальный индекс в V (позицию в matchV).Если v не в V, -1.
```if (v_index != -1 && !visited[v_index])```: Только если v в V и не посещали — отмечаем ```visited[v_index] = true```. 
**Зачем visited?** Предотвращает повторное использование в пути.

**Зачем matchInV[v] != -1**
- **colors:** "v в левой доле?" (грубый фильтр).
- **indexInV:** "Какой у v номер в моей таблице паросочетания?" (точный доступ).

    - *Граф может иметь изолированные вершины или не все с colors==1 в активном V*

    - *Без indexInV ты бы не знал, как адресовать matchV — пришлось бы хранить matchV размером n (с -1 для U), что расточительно в памяти (O(n) vs O(|V|)).*

1. 
```cpp
if (matchV[v_index] == -1 || dfsKuhn(matchV[v_index], ...))
```

- **Если** v свободна (matchV[v_index] == -1) ИЛИ рекурсия для текущего "партнёра" v ```(matchV[v_index])``` успевает найти новый путь (возвращает true).
**Рекурсия:** Вызываем dfsKuhn для "текущего владельца" v (это вершина в U, занятая v). Это пытается "переподвесить" его на другой v, освобождая этот.
- **Если** условие true, обновляем matching (инвертируем рёбра): 

```cpp
matchU[u] = v_index; 
matchV[v_index] = u; 
return true;
```