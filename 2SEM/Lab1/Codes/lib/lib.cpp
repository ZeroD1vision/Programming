/******************************************************************************
 *                               Курс Информатика                              *
 *******************************************************************************
 * Project type  : Linux Console Application                                   *
 * Project name  : Lab_2                                                       *
 * File name     : lib.cpp                                                     *
 * Language      : CPP                                                         *
 * Programmers   : Шалаев Александр Максимович, Нарзиев Артемий Тимурович      *
 * Modified By   :                                                             *
 * Created       : 02.04.2025                                                  *
 * Last Revision : 10.04.2025                                                  *
 * Comment       : Двумерные массивы. Вариант: 6                               *
 ******************************************************************************/
#include "lib.h"
#include <iostream>
#include <fstream>

// ######################## ДЛЯ СТАТИЧЕСКИХ МАССИВОВ ####################### //

/*********************************************************
 * @brief ф-я для считывания матриц из файла
 *
 * Ф-я считывает квадратные матрицы
 * первым числом в файле является размер матрицы
 * далее в файле идут числовые значения
 *
 * @param file - файловый поток
 * @param matrix - матрица, в которую будут сохраняться значения
 * @param N - указатель на считанный размер матрицы
 *********************************************************/
int reading_matrix(const char *FILE_NAME, int matrix[][N_MAX], int *N)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int count = 0; // счётчик считанных значений
    int i = 0;     // счётчики
    int j = 0;

    // ПРОВЕРКА
    std::ifstream file(FILE_NAME); // открыли файл

    if (!file.is_open())
    { // если файл не существует
        file.close();
        return -1;
    }
    if (file.peek() == EOF)
    { // если файл пустой
        file.close();
        return -2;
    }

    file >> *N; // считали размер матрицы

    if (file.fail())
    { // если встретили букву
        file.close();
        return -3;
    }
    if (*N < 0)
    { // если размер < 0
        file.close();
        return -4;
    }
    if (*N > N_MAX)
    { // если размер больше допустимого
        file.close();
        return -5;
    }

    // СЧИТЫВАНИЕ ЗНАЧЕНИЙ ИЗ МАТРИЦЫ

    // считывем матрицу пока файл не закончится
    // или пока она полностью не считается
    for (i = 0; i < *N && !file.eof(); i++)
    {
        for (j = 0; j < *N && !file.eof(); j++)
        {
            file >> matrix[i][j]; // считываем значение
            // если при считывании произошла ошибка
            if (file.fail())
            {
                file.close();
                return -6;
            }
            count++; // вычисляем кол-во считанных значений
        } // for j
    } // for i

    // если кол-во считанных значений не равер ожидаемому кол-ву
    // возвращаем это кол-во + 1, так как, если считано 0 значений
    // код будет 0, но это код успешного выполнения
    if (count != *N * *N)
    {
        file.close();
        return count + 1;
    }
    // если после считанных значений присутствуют лишние
    if (!file.eof())
    {
        file.close();
        return -7;
    }

    return 0;
}

/*********************************************************
 * @brief ф-я вычисления произведения отрицательных элементов над главной диагональю матрицы
 *
 * @param matrix - матрица
 * @param N - реальный размер матрицы
 *********************************************************/
int multiplication_neg_el(int matrix[][N_MAX], int N)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int result = 1;    // результат
    bool flag = false; // флаг отвечающий за наличие подходящих эл.
    int i = 0;         // счётчики
    int j = 0;

    // ВЫЧИСЛЕНИЕ
    // проверяем все элементы над главной диагональю
    for (i = 0; i < N; i++)
    {
        for (j = i + 1; j < N; j++)
        {
            // если эл. отрицательный
            if (matrix[i][j] < 0)
            {
                flag = true; // переводим флаг
                // и пересчитываем результат
                result *= matrix[i][j];
            } // if
        } // for j
    } // for i
    // если не умножили ни одного эл.
    if (!flag)
    {
        return 0;
    }
    return result;
}

/*********************************************************
 * @brief ф-я нахождения минимального нечётного эл.
 *
 * @param matrix - матрица
 * @param N - реальный размер матрицы
 *********************************************************/
int min_odd_el(int matrix[][N_MAX], int N)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int res = 0; // результат
    int i = 0;   // счётчики
    int j = 0;

    // ПОИСК ПЕРВОГО ПОДХОДЯЩЕГО
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < N; j++)
        {
            // если эл. нечетный
            if (matrix[i][j] % 2 != 0)
            {
                // то присваем его и выходим
                res = matrix[i][j];
                break;
            } // if
        } // for j
    } // for i

    // проверка, если в матрице нет нечётных эл.
    if (res == 0)
    {
        return 0;
    } // if

    // ВЫЧИСЛЕНИЕ
    // проверяем элементы
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < N; j++)
        {
            if (matrix[i][j] < res && matrix[i][j] % 2 != 0)
            {
                res = matrix[i][j];
            } // if
        } // for j
    } // for i

    return res;
}

// ####################### ДЛЯ ДИНАМИЧЕСКИХ МАССИВОВ ####################### //

/*********************************************************
 * @brief ф-я нахождения считывания размера матрицы из файла
 *
 * также данная ф-я проверяет существование файла и подобные ошибки
 * возвращает считанное значение или отрицательный код ошибки
 *
 * @param FILE_NAME - имя файла
 *********************************************************/
int reading_size_of_matrix(const char *FILE_NAME)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int N = 0; // считываемый размер матрицы

    // ПРОВЕРКА
    std::ifstream file(FILE_NAME);

    if (!file.is_open())
    { // если файл не существует
        file.close();
        return -1;
    }
    if (file.eof())
    { // если файл пустой
        file.close();
        return -2;
    }

    file >> N; // считали размер матрицы

    if (file.fail())
    { // если встретили букву
        file.close();
        return -3;
    }
    if (N < 0)
    { // если размер < 0
        file.close();
        return -4;
    }

    return N;
}

/*********************************************************
 * @brief ф-я для считывания динамических матриц из файла
 *
 * Ф-я считывает квадратные матрицы
 * первым числом в файле является размер матрицы
 * далее в файле идут числовые значения
 *
 * @param FILE_NAME - имя файла
 * @param matrix - матрица, в которую будут сохраняться значения
 * @param N - указатель на считанный размер матрицы
 *********************************************************/
int reading_dinamic_matrix(const char *FILE_NAME, int **matrix, int N)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int count = 0; // счётчик считанных значений
    int i = 0;     // счётчики
    int j = 0;

    // СЧИТЫВАНИЕ ЗНАЧЕНИЙ ИЗ МАТРИЦЫ
    std::ifstream file(FILE_NAME);
    // пропускаем N без проверки, так как уже
    // проверили размер в отдельной ф-ии
    file >> N;

    // считывем матрицу пока файл не закончится
    // или пока она полностью не считается
    for (i = 0; i < N && !file.eof(); i++)
    {
        for (j = 0; j < N && !file.eof(); j++)
        {
            file >> *(*(matrix + i) + j); // считываем значение
            // если при считывании произошла ошибка
            if (file.fail())
            {
                file.close();
                return -6;
            }
            count++; // вычисляем кол-во считанных значений
        } // for j
    } // for i

    // если кол-во считанных значений не равер ожидаемому кол-ву
    // возвращаем это кол-во + 1, так как, если считано 0 значений
    // код будет 0, но это код успешного выполнения
    if (count != N * N)
    {
        file.close();
        return count + 1;
    }
    // если после считанных значений присутствуют лишние
    if (!file.eof())
    {
        file.close();
        return -7;
    }

    file.close();
    return 0;
}

/*********************************************************
 * @brief ф-я вычисления произведения отрицательных элементов над главной диагональю матрицы
 *
 * @param matrix - матрица
 * @param N - реальный размер матрицы
 *********************************************************/
int dinamic_multiplication_neg_el(int **matrix, int N)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int result = 1;    // результат
    bool flag = false; // флаг отвечающий за наличие подходящих эл.
    int i = 0;         // счётчики
    int j = 0;

    // ВЫЧИСЛЕНИЕ
    // проверяем все элементы над главной диагональю
    for (i = 0; i < N; i++)
    {
        for (j = i + 1; j < N; j++)
        {
            // если эл. отрицательный
            if (*(*(matrix + i) + j) < 0)
            {
                flag = true; // переводим флаг
                // и пересчитываем результат
                result *= *(*(matrix + i) + j);
            } // if
        } // for j
    } // for i
    // если не умножили ни одного эл.
    if (!flag)
    {
        return 0;
    }
    return result;
}

/*********************************************************
 * @brief ф-я нахождения минимального нечётного эл.
 *
 * @param matrix - матрица
 * @param N - реальный размер матрицы
 *********************************************************/
int dinamic_min_odd_el(int **matrix, int N)
{
    // ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
    int res = 0; // результат
    int i = 0;   // счётчики
    int j = 0;

    // НАХОЖДЕНИЕ ПЕРВОГО НЕЧЁТНОГО
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < N; j++)
        {
            if (*(*(matrix + i) + j) % 2 != 0)
            {
                res = *(*(matrix + i) + j);
                break;
            } // if
        } // for j
    } // for i

    if (res == 0)
    {
        return 0;
    }

    // ВЫЧИСЛЕНИЕ
    // проверяем элементы
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < N; j++)
        {
            // если элемент нечётный и меньше сохранённого
            if (*(*(matrix + i) + j) < res && *(*(matrix + i) + j) % 2 != 0)
            {
                res = *(*(matrix + i) + j);
            } // if
        } // for j
    } // for i

    return res;
}

/******************************* КОНЕЦ lib.cpp *******************************/